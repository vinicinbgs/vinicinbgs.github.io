---
title: 'Desvendando os Segredos do Sistema: A Magia da Observabilidade'
date: 2024-06-04
slug: '/observability-metrics-and-monitoring'
description: 'How can we listening the software statistics?'
tags: 
  - observabilidade
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';


O Objetivo do artigo √© instruir sobre os conceitos de Observabilidade, Logs, M√©tricas e Tracing baseando-se na literatura e experi√™ncia pr√°tica em grandes empresas.  

Vamos aprender a aplica-los em um projeto pr√°tico e como eles se relacionam.


# Table of Contents

- [Table of Contents](#table-of-contents)
  - [üî≠ Afinal, Observabilidade](#-afinal-observabilidade)
    - [Tr√™s Pilares da Observabilidade](#tr√™s-pilares-da-observabilidade)
    - [Conclus√£o](#conclus√£o)
  - [ 1. üìú Logs: Segredos Escondidos no C√≥digo](#-1--logs-segredos-escondidos-no-c√≥digo)
    - [ 1.1. Introdu√ß√£o](#-11-introdu√ß√£o)
    - [ 1.2. N√≠veis de Logs](#-12-n√≠veis-de-logs)
    - [ 1.3. Formato de Logs](#-13-formato-de-logs)
      - [1.3.1. Estruturados](#131-estruturados)
      - [1.3.2. Semi-Estruturados](#132-semi-estruturados)
      - [1.3.3. Desestruturados](#133-desestruturados)
    - [ 1.4. Implementa√ß√£o](#-14-implementa√ß√£o)
    - [ 1.5. Arquitetura](#-15-arquitetura)
    - [Conclus√£o](#conclus√£o-1)
  - [ 2. üìà M√©tricas: Decifrando o Desempenho do Software](#-2--m√©tricas-decifrando-o-desempenho-do-software)
    - [2.1. M√©tricas de Recursos (CPU, Mem√≥ria, Disco, Rede)](#21-m√©tricas-de-recursos-cpu-mem√≥ria-disco-rede)
    - [2.2. M√©tricas de Servi√ßo (Four Golden Signals)](#22-m√©tricas-de-servi√ßo-four-golden-signals)
    - [2.2. Algumas Boas Pr√°ticas](#22-algumas-boas-pr√°ticas)
    - [2.3. Arquitetura](#23-arquitetura)
    - [Conclus√£o](#conclus√£o-2)
  - [ 3. üë£ Tracing: Rastreando Segredos](#-3--tracing-rastreando-segredos)
      - [Exemplo](#exemplo)
    - [3.1. Distributed Tracing](#31-distributed-tracing)
    - [Conclus√£o](#conclus√£o-3)
  - [ 4. üö® Monitoramento: Desvendando Mist√©rios em Tempo Real](#-4--monitoramento-desvendando-mist√©rios-em-tempo-real)
    - [Conclus√£o](#conclus√£o-4)
  - [Refer√™ncias](#refer√™ncias)

> ‚ÄúYou can't manage what you can't measure.‚Äù
> 
> -- <cite>Peter Drucker</cite>

---

## <a name="what-is-observability"></a>üî≠ Afinal, Observabilidade

O termo surgiu em 1960 na √°rea de engenharia de controle, introduzido pelo engenheiro Rudolf E. K√°lm√°n, e foi popularizado por [On The General Theory of Control Systems](https://www.control.utoronto.ca/~broucke/ece410f/kalman.pdf).

Na Teoria de Controle, Observabilidade √© uma medida dos estados internos de um sistema que podem ser inferidos a partir do conhecimento de suas sa√≠das externas.

O que significa que a `observabilidade prop≈çe saber como o sistema chegou em um estado olhando suas sa√≠das`.

Dessa forma permite lidar com problemas atuais e at√© solucionar problemas novos.

Mas nem tudo √© m√°gica... Para ser capaz de identificar um estado de um sistema olhando suas sa√≠das, a aplica√ß√£o deve ser devidamente `instrumentada`, ou seja, deve emitir sinais que possam ser capturados e analisados. 

Dividimos esses sinais em 3 pilares `traces`, `m√©tricas` e `logs`. Por√©m s√≥ ter os sinais n√£o √© suficiente, √© necess√°rio coletar, transmitir e armazenar esses dados.

A coleta, transmiss√£o e armazenamento desses dados chamamos de `Telemetria`.

![telemetria](./telemetry.png)
*Generated by DALL-E*

Uma aplica√ß√£o √© devidamente instrumentada quando os desenvolvedores n√£o precisam adicionar mais instrumentos para solucionar um problema, porque eles t√™m todas as informa√ß√µes de que precisam, ou seja, sem a necessidade de fazer um novo deploy para adicionar mais instrumentos. `Entenda como instrumentos: softwares novos, altera√ß√µes de arquivos ou configura√ß√µes, etc.`

Claro, essa maturidade √© atingida com o tempo, e √© um processo cont√≠nuo de melhoria, seria imposs√≠vel instrumentar tudo de uma vez, pois sempre haver√° problemas que n√£o se manifestaram... ainda.

### Tr√™s Pilares da Observabilidade
| Pilar    | Descri√ß√£o                                                                                       |
| -------- | ----------------------------------------------------------------------------------------------- |
| M√©tricas | Mede quantitivamente, comumente usada para comparar, rastrear desempenho em uma linha do tempo. |
| Logs     | Registro de que um evento ocorreu                                                               |
| Tracing  | Tracing √© um mecanismo para acompanhar o fluxo e a progress√£o dos dados de um software          |

### Conclus√£o

Aplica√ß√µes bem instrumentadas s√£o capazes de responder perguntas sobre seu comportamento an√°lisando-as de fora, e isso √© o que chamamos de `Observabilidade`.

Instrumentar aplica√ß√µes √© o ato de emitir sinais, esses sinais s√£o divididos em 3 pilares: `traces`, `m√©tricas` e `logs`.

`Telemetria` √© o processo de coletar, transmitir e armazenar esses sinais.

---

## <a name="what-are-logs"></a> 1. üìú Logs: Segredos Escondidos no C√≥digo

### <a name="log-introduction"></a> 1.1. Introdu√ß√£o

Todo software executa m√©todos/fun√ß√µes, essas execu√ß√µes na maioria das vezes tem algo as nos dizer que fazem valer a pena serem registradas. Ent√£o...  
`Logs s√£o registro de eventos que ocorrem no software.`  

Abaixo listo alguns tipos de logs:
- <u>Application Logs</u>
- Audit Logs
- Authorization and Access Logs
- Change Logs
- Event Logs
- Resource Logs
- Server Logs
- System Logs
- Threat Logs
- Transaction Logs

Vamos abordar apenas os logs de aplica√ß√£o, que s√£o logs gerados por uma aplica√ß√£o em execu√ß√£o.

**Normalmente em um registro de log de aplica√ß√£o encontramos:**
- `Timestamp`
- `Mensagem`
- `N√≠vel`
- `Dados de Contexto`

### <a name="log-level"></a> 1.2. N√≠veis de Logs
- `DEBUG` - Informa√ß√µes detalhadas, normalmente de interesse apenas ao desenvolvedor.
- `INFO` - Captura que eventos ocorreram, mas n√£o s√£o erros.
- `WARN` - Indica que algo inesperado aconteceu, mas o software ainda √© capaz de funcionar.
- `ERROR` - Indica que pelo menos um componente do sistema falhou e pode interferir em parte ou no funcionamento geral.
- `FATAL` - Indica que o sistema n√£o pode continuar a funcionar.


### <a name="log-formats"></a> 1.3. Formato de Logs

Abaixo vamos ver algumas estruturas de logs mais encontradas no mercado. O JSON costuma ser o mais utilizado por ser f√°cil de parsear e por ser estruturado.

#### 1.3.1. Estruturados

<Tabs>
  <TabItem value="json" label="JSON" default>
    ![structured_logs](./structured_logs.png)

    No exemplo acima perceba que existem dois campos `trace_id` e `span_id`, vamos aborda-los mais a frente.
  </TabItem>
  <TabItem value="xml" label="XML">
    ```xml
    <log>
      <timestamp>2024-07-10T14:45:23Z</timestamp>
      <level>INFO</level>
      <message>User logged in</message>
      <user>john.doe</user>
      <ip>127.0.0.1</ip>
    </log>
    ```
  </TabItem>
  <TabItem value="csv" label="CSV">
    ```csv
    timestamp,level,message,user,ip
    2024-07-10T14:45:23Z,INFO,User logged in,john.doe,127.0.0.1
    ```
  </TabItem>
  <TabItem value="logfmt" label="Logfmt">
    ```txt
    timestamp="2024-07-10T14:45:23Z" level=INFO message="User logged in" user="john.doe" ip="127.0.0.1"
    ```
  </TabItem>
  <TabItem value="syslog" label="Syslog (RFC 5424)">
    ```txt
    <165>1 2003-10-11T22:14:15.003Z mymachine.example.com evntslog - ID47 [exampleSDID@32473 iut="3" eventSource="Application" eventID="1011"][examplePriority@32473 class="high"]
    ```
  </TabItem>
</Tabs>

---

#### 1.3.2. Semi-Estruturados
<Tabs>
  <TabItem value="cef" label="Common Event Format (CEF)">
    ```txt
    CEF:0|Security|ThreatDetection|1.0|100|User logged in|5|msg=User logged in src=127.0.0.1 user=john.doe
    ```
  </TabItem>
  <TabItem value="clf" label="NCSA Common Log Format (CLF)">
    ```txt
    192.168.0.1 - jane [08/Jul/2024:10:23:45 +0000] "POST /login HTTP/1.1" 302 512
    ```
  </TabItem>
</Tabs>

---

#### 1.3.3. Desestruturados

![unstructured_logs](./unstructured_logs.png)

---

Qual a diferen√ßa entre `Semi-Estruturado`, `Estruturado` e `Desestruturado`?  

**Semi-Estruturados** possuem uma estrutura fixa, por√©m os campos n√£o s√£o fixos.  
> *Por exemplo, `Logfmt` tem sempre a mesma estrutura `key=value` com separador de espa√ßo, por√©m os campos podem variar.*

**Estruturados** possuem uma estrutura fixa e os campos s√£o fixos.  
> *Por exemplo, `JSON` possui sempre os mesmos campos (se assim for implementado), ou seja, todos os logs possuem os mesmos campos, como `timestamp`, `level`, `message` e `extra`, por√©m os valores podem variar.*

**Desestruturados** n√£o possuem uma estrutura fixa, ou seja, os campos e valores podem variar. 
> *Por exemplo, logs de texto puro.*

### <a name="log-implementation"></a> 1.4. Implementa√ß√£o

Como utilizar logs em uma aplica√ß√£o? Abaixo vemos um snippet de c√≥digo da aplica√ß√£o Flask em Python que construi para exemplificar esse artigo.

```py
@app.route('/')
def hello():
  message = f"Hello from {MS_NAME}!"
  Logger().info('app.py', {"response": message, "status": "200", "method": "GET", "path": "/", "app": MS_NAME})
  
  return message
```

O c√≥digo est√° emitindo um log estruturado atrav√©s da abstra√ß√£o `Logger` para sobrescrever o comportamento padr√£o do `logging` do Python.

Agora vamos an√°lisar o output em JSON do log gerado por esse c√≥digo.

```json
{
  "timestamp": "2024-07-05 19:59:37",
  "level": "INFO",
  "message": "app.py",
  "extra": {
    "response": "Hello from ms-one!",
    "status": "200",
    "method": "GET",
    "path": "/",
    "app": "ms-one"
  }
}
```

O destino desse output pode ser um arquivo, um banco de dados, um servi√ßo de log, etc. No nosso caso estamos apenas imprimindo o log no console `stdout` e `stderr`.

### <a name="log-architecture"></a> 1.5. Arquitetura

![Logs](./logging.png)

:::info

No exemplo acima o `promtail` √© um `agente que coleta logs dos containers` e envia para o `Loki`, que √© um `sistema de armazenamento de logs` enquanto o `Grafana` √© uma `ferramenta de visualiza√ß√£o de logs` que consome diretamente do Loki.

:::

**Armazenar logs acaba se tornando caro üí∞ ao longo do tempo**, por isso √© importante definir os eventos que realmente possuem valor e padronizar a estrutura de output.  

Busque **pontos estrat√©gicos dentro do c√≥digo da aplica√ß√£o para emitir logs com contextos relevantes**, isso vai ajudar a trackear o comportamento do software do lado de fora usando alguma ferramenta de visualiza√ß√£o de logs e  permitir que com esses dados sejam montadas dashboards com m√©tricas que ir√£o facilitar a descoberta de problemas e auxiliar√£o em tomadas de decis√µes.

### Conclus√£o

O log estruturado permite que voc√™ fa√ßa consultas mais complexas de forma mais f√°cil, e consiga atrav√©s dos logs construir m√©tricas.  

No log desestruturado o parseamento √© mais dif√≠cil pois a estrutura n√£o √© fixa, e a constru√ß√£o de m√©tricas pode se tornar mais complexa. Pode ocasionar na quebra de dashboards e m√©tricas dependendo de como a consulta foi constru√≠da.

:::warning
N√£o que n√£o seja poss√≠vel fazer m√©tricas com os logs Semi-Estruturado e Desestruturado, mas acaba se tornando dif√≠cil quando n√£o se possui um padr√£o.
:::

:::tip
**Defina as boas pr√°ticas de logging para sua aplica√ß√£o e siga-as:**
- Defina os n√≠veis de logs que devem ser emitidos em produ√ß√£o, n√£o emita `debug`.
- Defina o formato de output (JSON, XML, CSV...).
  - Defina os campos que devem ser emitidos.
  - Defina quando usar log de erro.
  - Defina quando usar log de info.
  - Defina quando usar log de warning.
  - Defina quando usar log de fatal.
- Projete o c√≥digo para emitir logs em pontos estrat√©gicos.
- Defina o destino dos logs (stdout, stderr, arquivo, banco de dados, servi√ßo de log, etc)
- Defina a politica de reten√ß√£o de logs (X dias).
:::

---

## <a name="what-are-metrics"></a> 2. üìà M√©tricas: Decifrando o Desempenho do Software

M√©tricas s√£o valores capturados em seus sistemas em um ponto espec√≠fico no tempo.  

**Exemplos:**
- o n√∫mero de usu√°rios que logaram em seus sistema nas √∫ltimas 2h
- o n√∫mero de requisi√ß√µes que sua aplica√ß√£o recebeu nas √∫ltimas 24h
- o tempo m√©dio de resposta de uma requisi√ß√£o dentro das √∫ltimas 1h

Podem ser coletadas uma vez por segundo, uma por minuto ou em outro intervalo regular para monitorar um sistema ao longo do tempo. Seus dados s√£o comumente armazenados em um banco de dados de s√©ries temporais, como o InfluxDB, Prometheus, Graphite, etc. No Prometheus a coleta √© feita atrav√©s de `scraping`.

Tamb√©m construimos m√©tricas atrav√©s dos logs de aplica√ß√£o, filtrando e agregando os dados dentro de um intervalo de tempo. Chamamos essa t√©cnica de [White-box monitoring](https://sre.google/sre-book/monitoring-distributed-systems/).

Por Exemplo, a partir dos logs da aplica√ß√£o que possuem o campo `extra_path="/health"`, podemos contar quantas vezes a rota `/health` foi requisitada em um intervalo de tempo. Veja abaixo:

![Metrics](./metrics_graph.png)

Foram feitos 3 requests para a rota `/health` em um intervalo de `~1 minutos`. Neste caso construimos uma m√©trica de `Tr√°fego` (Traffic).

### 2.1. M√©tricas de Recursos (CPU, Mem√≥ria, Disco, Rede)

M√©tricas de recursos s√£o m√©tricas que medem o uso de recursos de um sistema, como CPU, mem√≥ria, disco e rede. Essas m√©tricas s√£o essenciais para monitorar a sa√∫de e o desempenho de um sistema e identificar gargalos e problemas de desempenho.

| Sinal       | Descri√ß√£o                                                                             |
| ----------- | ------------------------------------------------------------------------------------- |
| Utilization | Mede a quantidade de recurso que est√° sendo usada.                                    |
| Saturation  | Mede o grau em que um recurso est√° perto de sua capacidade m√°xima ou al√©m.            |
| Errors      | Mede a quantidade de erros que ocorreram ao usar um recurso.                          |
| Jitter      | Mede a varia√ß√£o que o pacote na rede √© transmitido e quando ele √© recebido.           |
| Capacity    | Mede a quantidade m√°xima de trabalho que um sistema pode realizar. Ex: 8GB RAM, 3vCPU |

![Metrics](./metrics_resource.png)

### 2.2. M√©tricas de Servi√ßo (Four Golden Signals)

Apresentadas no livro SRE do Google, essas 4 m√©tricas s√£o destinadas a entender a experi√™ncia de uso do sistema do ponto de vista dos usu√°rios - Service-Oriented.

| Sinal      | Descri√ß√£o                                                                   |
| ---------- | --------------------------------------------------------------------------- |
| Latency    | Mede o tempo que o sistema leva para responder a uma solicita√ß√£o.           |
| Traffic    | Mede o n√∫mero de requisi√ß√µes que o sistema est√° recebendo.                  |
| Errors     | Mede o n√∫mero de erros que o sistema est√° retornando.                       |
| Saturation | Mede o grau no qual um recurso est√° perto da sua capacidade m√°xima ou al√©m. |

A m√©trica de desempenho mais comum √© a lat√™ncia, que representa o tempo necess√°rio para concluir uma unidade de trabalho. **A lat√™ncia pode ser expressa como uma m√©dia ou como um percentil, como "99% das solicita√ß√µes retornaram em 0,1s".**  

:::tip
A m√©dia √© muito usada para entender o desempenho geral de um sistema, por√©m a m√©dia n√£o √© um valor t√£o confi√°vel, pois pode ser distorcida por valores extremos, j√° os percentis s√£o √∫teis para entender o desempenho em diferentes quantis da distribui√ß√£o.
:::

Abaixo mostro uma dashboard para monitorar o uso total de CPU de um Container. Fiz uma simula√ß√£o de 1000 requests e podemos ver o pico de CPU.

![Metrics](./metrics_cpu_user.png)

![Metrics](./metrics_memory.png)


### 2.2. Algumas Boas Pr√°ticas

- **F√°cil de Entender** Deve ser possivel determinar rapidamente o que cada m√©trica ou evento representa.

- **Custo** Armazenar m√©tricas pode ser caro, ent√£o voc√™ deve coletar apenas o que √© realmente necess√°rio.

- **Granular** Se voc√™ coletar m√©tricas muito agregadas, voc√™ pode perder informa√ß√µes importantes. Por exemplo, se voc√™ coletar a m√©dia de lat√™ncia de uma solicita√ß√£o, voc√™ pode perder informa√ß√µes sobre picos de lat√™ncia que podem ser importantes para a experi√™ncia do usu√°rio. Se voc√™ coletar m√©tricas muito granulares, voc√™ pode acabar com muitos dados que s√£o dif√≠ceis de analisar. Encontre um equil√≠brio entre a granularidade e a agrega√ß√£o que funcione para voc√™.

- **Etiqueta de Escopo** Cada um dos seus hosts opera simultaneamente em v√°rios escopos, e voc√™ pode querer verificar a sa√∫de de qualquer um desses escopos, ou suas combina√ß√µes. Por exemplo: como est√° a m√©trica X total? E a m√©trica X no Nordeste dos EUA?.

- **Vida √∫til** Mantenha uma pol√≠tica de reten√ß√£o de dados que permita que voc√™ investigue problemas passados e identifique tend√™ncias ao longo do tempo.

### 2.3. Arquitetura

![Metrics](./metrics.png)

### Conclus√£o

As m√©tricas conseguem informar o estado passado e presente do sistema, e ajudam a prever comportamentos que podem ocorrer no futuro.  

Respondem qual parte do software est√° sendo mais acessada, qual parte est√° consumindo mais recursos, qual parte est√° mais lenta...

N√£o se resumem a apenas m√©tricas de recurso, mas tamb√©m a m√©tricas de neg√≥cio, como o n√∫mero de vendas, o n√∫mero de usu√°rios ativos...  

Mas lembre-se, m√©tricas s√£o apenas n√∫meros, e para entender o que esses n√∫meros significam, voc√™ precisa de logs.

---

## <a name="what-is-tracing"></a> 3. üë£ Tracing: Rastreando Segredos

O objetivo principal do tracing √© fornecer visibilidade detalhada sobre como o processamento daquela chamada foi feito, e como ela se relaciona com outras chamadas. 

Quando essa requisi√ß√£o se extende para fora da aplica√ß√£o, o tracing se torna distribu√≠do, chamamos-o de [Distributed Tracing](#31-distributed-tracing).

Uma aplica√ß√£o CLI por exemplo, pode ser instrumentada para gerar traces.

Isso √© feito registrando cada opera√ß√£o ou evento importante durante o ciclo de vida de uma requisi√ß√£o.

Um dos principais componentes do tracing √© o conceito de `span`. 

```txt
TRACE
  |-- SPAN
  |     |-- LOG
  |     |-- LOG
  |     |-- LOG
  |-- SPAN
  |     |-- LOG
  |     |-- LOG
```

Note que um `span` pode conter v√°rios `logs`.

Um span representa uma unidade de trabalho ou opera√ß√£o e cont√©m informa√ß√µes como:

- Nome da opera√ß√£o
- In√≠cio e fim da opera√ß√£o (timestamps)
- Metadados ou atributos adicionais (como IDs de usu√°rio, tipos de opera√ß√µes, etc.)
- Relacionamento com outros spans (pai-filho)
- Logs associados √† opera√ß√£o

Os spans podem ser organizados em uma hierarquia que reflete a estrutura da execu√ß√£o da requisi√ß√£o, facilitando a visualiza√ß√£o de como uma requisi√ß√£o √© processada de ponta a ponta dentro de uma aplica√ß√£o.

#### Exemplo

Abaixo mostro o output de uma classe python que criei que gera logs estruturados. Nela √© poss√≠vel ver dois `spans` que foram gerados para o mesmo `trace_id`.

Por√©m ela √© b√°sica, ou seja, n√£o possui o conceito de que um `span` possui `1..N logs`. Vemos que `1 span` possui `1 log`.

Perceba que o `trace_id` √© o mesmo para os dois `spans`, isso indica que ambos os `spans` fazem parte da **mesma requisi√ß√£o**.

Essa requisi√ß√£o est√° executando 2 m√©todos diferentes da aplica√ß√£o, e ambos os m√©todos est√£o gerando logs.

![tracing](./tracing_loggingz.png)

### 3.1. Distributed Tracing

<img src={require("./tracing_call.png").default} alt="Tracing" width="400"/>

O distributed tracing (rastreamento distribu√≠do) se expande para ambientes onde m√∫ltiplas aplica√ß√µes e servi√ßos colaboram para processar uma requisi√ß√£o. 

Em um sistema distribu√≠do, uma √∫nica requisi√ß√£o pode atravessar v√°rias aplica√ß√µes e servi√ßos, cada um deles contribuindo com uma parte do processamento.

O distributed tracing tem como objetivo fornecer visibilidade ponta a ponta de como as requisi√ß√µes fluem atrav√©s de um sistema distribu√≠do, identificando pontos de lat√™ncia, gargalos e falhas.

![distributed-tracing](./tracing_oltp.png)

### Conclus√£o

O tracing √© uma ferramenta poderosa para entender como as requisi√ß√µes s√£o processadas em uma aplica√ß√£o e como elas se relacionam com outras requisi√ß√µes.

O tracing √© especialmente √∫til em sistemas distribu√≠dos, onde v√°rias aplica√ß√µes e servi√ßos colaboram para processar uma requisi√ß√£o. 

Mas tamb√©m √© muito √∫til em sistemas onde uma requisi√ß√£o pode ser processada por v√°rias partes da aplica√ß√£o.

---

## <a name="what-is-monitoring"></a> 4. üö® Monitoramento: Desvendando Mist√©rios em Tempo Real

Monitoramento √© o ato de ativamente observar o estado de um sistema para detectar problemas e tomar medidas corretivas.

O monitoramento √© uma parte essencial da observabilidade, pois fornece informa√ß√µes em tempo real sobre o estado de um sistema e ajudam a identificar que est√° ocorrendo problemas.

Usamos alertas para notificar os operadores do sistema quando alguma politica de alerta √© violada. Esses alertas ajudam a manter os operadores do sistema cientes sobre o que est√° acontecendo.

Exitem duas abordagens de Monitoramento, chamamos de Ativo e Passivo

| Aspecto                   | Monitoramento Ativo                                           | Monitoramento Passivo                                       |
| ------------------------- | ------------------------------------------------------------- | ----------------------------------------------------------- |
| **M√©todo**                | Envia requisi√ß√µes/sondas ao sistema                           | Observa o tr√°fego de rede e coleta logs                     |
| **Proatividade**          | Proativo                                                      | Reativo                                                     |
| **Sobrecarga**            | Pode adicionar carga adicional ao sistema                     | Baixa sobrecarga                                            |
| **Detec√ß√£o de Problemas** | Detecta problemas rapidamente atrav√©s de sondagens constantes | Pode detectar problemas ap√≥s eles terem ocorrido            |
| **Vantagens**             | Detec√ß√£o r√°pida, a√ß√£o preventiva, m√©tricas detalhadas         | Baixa sobrecarga, informa√ß√µes detalhadas, an√°lise hist√≥rica |
| **Desvantagens**          | Sobrecarga de rede, poss√≠veis falsos positivos                | Reatividade, depend√™ncia de qualidade de logs               |

A pr√°tica do monitoramento ativo √© comum em sistemas cr√≠ticos, onde a detec√ß√£o de problemas e a√ß√£o preventiva s√£o essenciais para garantir a disponibilidade e confiabilidade do sistema. 

Pense que voc√™ fica cutucando o sistema para ver se ele est√° responsivo e funcionando como deveria.

J√° a pr√°tica do monitoramento passivo √© comum para todos os sistemas.

### Conclus√£o

Para monitorar um sistema de forma eficaz, defina m√©tricas e thresholds para que quando um threshold for violado, um alerta seja disparado e o operador do sistema receba notifica√ß√£o.

Mas tome cuidado com o excesso de alertas, pois isso pode levar a fadiga de alertas e fazer com que os operadores ignorem alertas importantes.

---

## Refer√™ncias
- https://www.oreilly.com/library/view/observability-engineering/9781492076438/
- https://www.manning.com/books/software-telemetry
- https://sre.google/sre-book/table-of-contents/ (Free to Read Online)